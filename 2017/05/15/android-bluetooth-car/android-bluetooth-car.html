<hr>
<p>title: 基于Android蓝牙4.0实现终端遥控蓝牙小车<br>date: 2017-05-15 19:46:39</p>
<h2 id="tags-Android-蓝牙4-0"><a href="#tags-Android-蓝牙4-0" class="headerlink" title="tags: Android 蓝牙4.0"></a>tags: Android 蓝牙4.0</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每年的四五月份是我们学院的科创月，今年在智能车单元组里面开设了蓝牙小车比赛。之前学习Android开发基本没有接触到蓝牙知识，趁这个机会恶补一番。</p>
<h2 id="蓝牙低功耗-BLE"><a href="#蓝牙低功耗-BLE" class="headerlink" title="蓝牙低功耗 BLE"></a>蓝牙低功耗 BLE</h2><p>谷歌在Android 4.3(API18)引入了蓝牙低功耗的概念，即所谓的蓝牙4.0，具有以下特性：</p>
<ul>
<li>在附近设备之间传输少量数据。</li>
<li>与Google Beacon之类的接近传感器进行交互，可以根据用户的当前位置为用户提供自定义的体验。</li>
</ul>
<blockquote>
<ul>
<li>Transferring small amounts of data between nearby devices.</li>
<li>Interacting with proximity sensors like Google Beacons to give users a customized experience based on their current location.</li>
</ul>
</blockquote>
<p>这里的蓝牙小车基于51单片机和HC05或者CC2541蓝牙模块，手机端通过蓝牙4.0协议与小车蓝牙模块进行通信，从而实现终端控制蓝牙小车的功能。</p>
<h2 id="BLE权限"><a href="#BLE权限" class="headerlink" title="BLE权限"></a>BLE权限</h2><p>在清单文件声明蓝牙权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH&quot;/&gt;
&lt;uses-permission android:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&gt;
</code></pre><p>如果要声明应用仅适用于支持BLE的设备，可以在应用的清单中包含以下内容：</p>
<pre><code>&lt;uses-feature android:name=&quot;android.hardware.bluetooth_le&quot; android:required=&quot;true&quot;/&gt;
</code></pre><p>判断设备是否支持BLE</p>
<pre><code>// Use this check to determine whether BLE is supported on the device. Then
// you can selectively disable BLE-related features.
if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) {
    Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show();
    finish();
</code></pre><p>}</p>
<h2 id="配置BLE"><a href="#配置BLE" class="headerlink" title="配置BLE"></a>配置BLE</h2><h3 id="1-获取BluetoothAdapter"><a href="#1-获取BluetoothAdapter" class="headerlink" title="1.获取BluetoothAdapter"></a>1.获取BluetoothAdapter</h3><pre><code>private BluetoothAdapter mBluetoothAdapter;
...
// Initializes Bluetooth adapter.
final BluetoothManager bluetoothManager =
    (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
mBluetoothAdapter = bluetoothManager.getAdapter();
</code></pre><h3 id="2-Enable蓝牙"><a href="#2-Enable蓝牙" class="headerlink" title="2.Enable蓝牙"></a>2.Enable蓝牙</h3><pre><code>// Ensures Bluetooth is available on the device and it is enabled. If not,
// displays a dialog requesting user permission to enable Bluetooth.
if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) {
    Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
    startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
}
</code></pre><h3 id="3-扫描BLE设备"><a href="#3-扫描BLE设备" class="headerlink" title="3.扫描BLE设备"></a>3.扫描BLE设备</h3><pre><code>private BluetoothAdapter mBluetoothAdapter;
private boolean mScanning;
private Handler mHandler;

// Stops scanning after 10 seconds.
private static final long SCAN_PERIOD = 10000;
...
private void scanLeDevice(final boolean enable) {
    if (enable) {
        // Stops scanning after a pre-defined scan period.
        mHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                mScanning = false;
                mBluetoothAdapter.stopLeScan(mLeScanCallback);
            }
        }, SCAN_PERIOD);

        mScanning = true;
        mBluetoothAdapter.startLeScan(mLeScanCallback);
    } else {
        mScanning = false;
        mBluetoothAdapter.stopLeScan(mLeScanCallback);
    }
    ...
}
</code></pre><p>其中mLeScanCallback是BluetoothAdapter.LeScanCallback的实现，它是用于传递BLE扫描结果的接口：</p>
<pre><code>private LeDeviceListAdapter mLeDeviceListAdapter;
...
// Device scan callback.
private BluetoothAdapter.LeScanCallback mLeScanCallback =
        new BluetoothAdapter.LeScanCallback() {
    @Override
    public void onLeScan(final BluetoothDevice device, int rssi,
            byte[] scanRecord) {
        runOnUiThread(new Runnable() {
           @Override
           public void run() {
               mLeDeviceListAdapter.addDevice(device);
               mLeDeviceListAdapter.notifyDataSetChanged();
           }
       });
   }
};
</code></pre>